<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>The Invisible Setup: Installing Raspbian on Raspberry Pi Without a Monitor</title>
      <link href="/2024/07/25/The-Invisible-Setup-Installing-Raspbian-on-Raspberry-Pi-Without-a-Monitor/"/>
      <url>/2024/07/25/The-Invisible-Setup-Installing-Raspbian-on-Raspberry-Pi-Without-a-Monitor/</url>
      
        <content type="html"><![CDATA[<h1 id="Installing-Raspbian-on-Raspberry-Pi-Without-a-Monitor-A-Journey-of-Technological-Hijinks"><a href="#Installing-Raspbian-on-Raspberry-Pi-Without-a-Monitor-A-Journey-of-Technological-Hijinks" class="headerlink" title="Installing Raspbian on Raspberry Pi Without a Monitor: A Journey of Technological Hijinks"></a>Installing Raspbian on Raspberry Pi Without a Monitor: A Journey of Technological Hijinks</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Welcome, fellow tech enthusiasts, to the wild and wacky world of headless Raspberry Pi setup! Today, we’re diving into the delightful chaos of installing Raspbian on a Raspberry Pi without a monitor. Buckle up, because this is going to be a fun ride!</p><h2 id="What-You’ll-Need"><a href="#What-You’ll-Need" class="headerlink" title="What You’ll Need"></a>What You’ll Need</h2><p>Before we get started, here’s a quick checklist of what you’ll need:</p><ul><li>A Raspberry Pi (any model will do, but let’s go with the Raspberry Pi 4 for this adventure).</li><li>A microSD card (at least 8GB, but the bigger, the better).</li><li>A microSD card reader.</li><li>A computer with internet access.</li><li>A power supply for your Raspberry Pi.</li><li>An Ethernet cable (optional, but recommended for a smoother experience).</li></ul><h2 id="Step-1-Download-Raspbian"><a href="#Step-1-Download-Raspbian" class="headerlink" title="Step 1: Download Raspbian"></a>Step 1: Download Raspbian</h2><p>First things first, let’s get our hands on the latest Raspbian image. Head over to the <a href="https://www.raspberrypi.org/software/operating-systems/">official Raspberry Pi website</a> and download the Raspbian image. We recommend the “Raspberry Pi OS with desktop” version because, why not?</p><h2 id="Step-2-Flash-the-Image-to-the-SD-Card"><a href="#Step-2-Flash-the-Image-to-the-SD-Card" class="headerlink" title="Step 2: Flash the Image to the SD Card"></a>Step 2: Flash the Image to the SD Card</h2><p>Next, we need to flash the Raspbian image onto the microSD card. To do this, you can use a handy tool called <a href="https://www.balena.io/etcher/">balenaEtcher</a>.</p><ol><li>Download and install balenaEtcher.</li><li>Insert your microSD card into your card reader and connect it to your computer.</li><li>Open balenaEtcher, select the Raspbian image you downloaded, choose your microSD card, and hit “Flash!”.</li><li>Wait for the process to complete. This might take a few minutes, so feel free to grab a coffee or do a quick dance.</li></ol><h2 id="Step-3-Enable-SSH-and-Wi-Fi-The-Secret-Sauce"><a href="#Step-3-Enable-SSH-and-Wi-Fi-The-Secret-Sauce" class="headerlink" title="Step 3: Enable SSH and Wi-Fi (The Secret Sauce)"></a>Step 3: Enable SSH and Wi-Fi (The Secret Sauce)</h2><p>Here comes the magical part that makes this whole headless setup possible.</p><ol><li>Once the flashing is complete, remove and reinsert the microSD card into your computer.</li><li>Open the microSD card in your file explorer. You should see a bunch of files and folders.</li><li>Create a new empty file in the root of the microSD card and name it <code>ssh</code> (no file extension). This will enable SSH on your Raspberry Pi.</li><li>Next, create a file called <code>wpa_supplicant.conf</code> and add the following content to configure your Wi-Fi:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">country=US</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line"> ssid=&quot;YourNetworkName&quot;</span><br><span class="line"> psk=&quot;YourNetworkPassword&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Replace <code>YourNetworkName</code> and <code>YourNetworkPassword</code> with your actual Wi-Fi credentials.</p><h2 id="Step-4-Boot-Up-Your-Raspberry-Pi"><a href="#Step-4-Boot-Up-Your-Raspberry-Pi" class="headerlink" title="Step 4: Boot Up Your Raspberry Pi"></a>Step 4: Boot Up Your Raspberry Pi</h2><p>Now it’s time to bring your Raspberry Pi to life!</p><ol><li>Insert the microSD card into your Raspberry Pi.</li><li>Connect the power supply to your Raspberry Pi.</li><li>If you’re using an Ethernet cable, connect it now.</li></ol><p>Give it a minute or two to boot up and connect to your Wi-Fi network.</p><h2 id="Step-5-Find-Your-Raspberry-Pi’s-IP-Address"><a href="#Step-5-Find-Your-Raspberry-Pi’s-IP-Address" class="headerlink" title="Step 5: Find Your Raspberry Pi’s IP Address"></a>Step 5: Find Your Raspberry Pi’s IP Address</h2><p>To SSH into your Raspberry Pi, you need its IP address. There are a few ways to find it:</p><ul><li>Check your router’s device list for a new device.</li><li>Use a network scanning tool like <a href="https://angryip.org/">Angry IP Scanner</a>.</li></ul><h2 id="Step-6-SSH-into-Your-Raspberry-Pi"><a href="#Step-6-SSH-into-Your-Raspberry-Pi" class="headerlink" title="Step 6: SSH into Your Raspberry Pi"></a>Step 6: SSH into Your Raspberry Pi</h2><p>Once you have the IP address, open a terminal (or Command Prompt on Windows) and type the following command:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh pi@&lt;YourPiIPAddress&gt;</span><br></pre></td></tr></table></figure><p>Replace <code>&lt;YourPiIPAddress&gt;</code> with the actual IP address of your Raspberry Pi.</p><p>The default password for the <code>pi</code> user is <code>raspberry</code>. Once you’re in, change the password to something more secure using the <code>passwd</code> command.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>And there you have it! You’ve successfully installed Raspbian on your Raspberry Pi without using a monitor. Welcome to the headless club!</p><p>Feel free to explore and tinker with your newly set up Raspberry Pi. The possibilities are endless, and the fun has just begun!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Raspberry Pi </tag>
            
            <tag> Raspbian </tag>
            
            <tag> Headless Setup </tag>
            
            <tag> DIY Tech </tag>
            
            <tag> Fun with Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Container Wonderland: Running Open-WebUI and Ollama Smoothly</title>
      <link href="/2024/07/18/Container-Wonderland-Running-Open-WebUI-and-Ollama-Smoothly/"/>
      <url>/2024/07/18/Container-Wonderland-Running-Open-WebUI-and-Ollama-Smoothly/</url>
      
        <content type="html"><![CDATA[<h2 id="Running-Open-WebUI-with-Docker-A-Comprehensive-Guide"><a href="#Running-Open-WebUI-with-Docker-A-Comprehensive-Guide" class="headerlink" title="Running Open-WebUI with Docker: A Comprehensive Guide"></a>Running Open-WebUI with Docker: A Comprehensive Guide</h2><p>If you’re looking to deploy Open-WebUI and Ollama using Docker, you’re in the right place. Docker is a powerful tool for containerization that allows developers to package applications and their dependencies into a single unit, ensuring consistency across different environments. This guide will walk you through the process of running Open-WebUI and Ollama using Docker commands.</p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><p>Before we begin, make sure you have the following installed on your machine:</p><ol><li><strong>Docker</strong>: You can download and install Docker from <a href="https://www.docker.com/products/docker-desktop">here</a>.</li><li><strong>Basic Knowledge of Docker</strong>: Familiarity with Docker commands and concepts will be helpful.</li></ol><h3 id="Step-1-Running-Open-WebUI"><a href="#Step-1-Running-Open-WebUI" class="headerlink" title="Step 1: Running Open-WebUI"></a>Step 1: Running Open-WebUI</h3><p>First, let’s run the Open-WebUI container. The command below does the following:</p><ul><li><strong>Adds a host entry</strong> (<code>--add-host=host.docker.internal:host-gateway</code>): This maps the host IP address to <code>host.docker.internal</code> within the container.</li><li><strong>Maps Ports</strong> (<code>-p 8181:8080</code> and <code>-p 3000:8181</code>): The container’s port 8080 is mapped to host port 8181, and the container’s port 8181 is mapped to host port 3000.</li><li><strong>Mounts a Volume</strong> (<code>-v open-webui:/app/backend/data</code>): This creates a named volume <code>open-webui</code> and mounts it to <code>/app/backend/data</code> in the container, allowing data persistence.</li><li><strong>Sets Environment Variables</strong> (<code>-e OLLAMA_BASE_URL=http://localhost:11434</code> and <code>-e MAIN_LOG_LEVEL=debug</code>): Configures the base URL for Ollama and sets the logging level to debug.</li><li><strong>Names the Container</strong> (<code>--name open-webui</code>): Assigns the name <code>open-webui</code> to the container.</li><li><strong>Specifies the Image</strong> (<code>ghcr.io/open-webui/open-webui:main</code>): Uses the Open-WebUI image from the GitHub Container Registry.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --add-host=host.docker.internal:host-gateway -p 8181:8080 -v open-webui:/app/backend/data -p 3000:8181 -e OLLAMA_BASE_URL=http://localhost:11434 -e MAIN_LOG_LEVEL=debug --name open-webui ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure><h3 id="Step-2-Running-Ollama"><a href="#Step-2-Running-Ollama" class="headerlink" title="Step 2: Running Ollama"></a>Step 2: Running Ollama</h3><p>Next, let’s run the Ollama container. This command does the following:</p><ul><li><strong>Runs the Container in Detached Mode</strong> (<code>-d</code>): The container runs in the background.</li><li><strong>Mounts a Volume</strong> (<code>-v ollama:/.ollama</code>): Creates a named volume <code>ollama</code> and mounts it to <code>/.ollama</code> in the container, ensuring data persistence.</li><li><strong>Maps Ports</strong> (<code>-p 11434:11434</code>): The container’s port 11434 is mapped to the same port on the host.</li><li><strong>Names the Container</strong> (<code>--name ollama</code>): Assigns the name <code>ollama</code> to the container.</li><li><strong>Specifies the Image</strong> (<code>ollama/ollama</code>): Uses the Ollama image.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v ollama:/.ollama -p 11434:11434 --name ollama ollama/ollama</span><br></pre></td></tr></table></figure><h3 id="Verifying-the-Setup"><a href="#Verifying-the-Setup" class="headerlink" title="Verifying the Setup"></a>Verifying the Setup</h3><p>After running the above commands, verify that the containers are running smoothly:</p><ol><li><p><strong>List Running Containers</strong>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>You should see both <code>open-webui</code> and <code>ollama</code> containers listed.</p></li><li><p><strong>Access Open-WebUI</strong>:<br>Open your browser and navigate to <code>http://localhost:8181</code> to access Open-WebUI.</p></li><li><p><strong>Check Logs</strong>:<br>To check the logs for troubleshooting, use:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs open-webui</span><br><span class="line">docker logs ollama</span><br></pre></td></tr></table></figure></li></ol><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>By following this guide, you have successfully set up and run Open-WebUI and Ollama using Docker. This setup allows you to leverage containerization for a consistent and portable development environment. Feel free to explore further customizations and configurations to suit your specific needs.</p><p>Happy Dockering!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Torrenting for the Lazy: Deluge + Docker = Minimal Effort</title>
      <link href="/2024/07/17/Torrenting-for-the-Lazy-Deluge-Docker-Minimal-Effort/"/>
      <url>/2024/07/17/Torrenting-for-the-Lazy-Deluge-Docker-Minimal-Effort/</url>
      
        <content type="html"><![CDATA[<p>Managing torrents is much easier with Docker. This guide will show you how to set up Deluge, a popular BitTorrent client, using Docker Compose. By the end, you’ll have a fully functional Deluge setup running in a Docker container, making torrent management simple and quick.</p><h2 id="What-is-Docker-Compose"><a href="#What-is-Docker-Compose" class="headerlink" title="What is Docker Compose?"></a>What is Docker Compose?</h2><p>Docker Compose is a tool that allows you to define and run multi-container Docker applications. With a single command, you can start all the services from your configuration file.</p><h2 id="Why-Choose-Deluge"><a href="#Why-Choose-Deluge" class="headerlink" title="Why Choose Deluge?"></a>Why Choose Deluge?</h2><p>Deluge is a powerful, lightweight BitTorrent client that works across various platforms. It has a rich collection of plugins and supports many configurations, making it a favorite among torrent users.</p><h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>Before starting, make sure you have:</p><ol><li>Docker installed.</li><li>Docker Compose installed.</li><li>A basic understanding of Docker and container concepts.</li></ol><h2 id="Docker-Compose-Configuration"><a href="#Docker-Compose-Configuration" class="headerlink" title="Docker Compose Configuration"></a>Docker Compose Configuration</h2><p>Here’s a basic Docker Compose configuration for Deluge:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2.1&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">deluge:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">linuxserver/deluge:2.1.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">deluge</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PUID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PGID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Etc/UTC</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DELUGE_LOGLEVEL=error</span> <span class="comment"># optional</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/media/media0/deluge/config:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/media/media0/deluge/downloads:/downloads</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8112</span><span class="string">:8112</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6881</span><span class="string">:6881</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6881</span><span class="string">:6881/udp</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><h3 id="Configuration-Breakdown"><a href="#Configuration-Breakdown" class="headerlink" title="Configuration Breakdown"></a>Configuration Breakdown</h3><ul><li><code>version: &quot;2.1&quot;</code>: Specifies the Docker Compose file version.</li><li><code>services</code>: Lists the services to be deployed.</li><li><code>deluge</code>: The Deluge service.<ul><li><code>image</code>: The Docker image to use, here it’s <code>linuxserver/deluge:2.1.1</code>.</li><li><code>container_name</code>: Names the container for easier management.</li><li><code>environment</code>: Sets environment variables:<ul><li><code>PUID=1000</code> and <code>PGID=1000</code>: User and group IDs for permissions.</li><li><code>TZ=Etc/UTC</code>: Timezone.</li><li><code>DELUGE_LOGLEVEL=error</code>: Optional log level.</li></ul></li><li><code>volumes</code>: Maps host directories to container directories:<ul><li><code>/media/media0/deluge/config:/config</code>: For configuration files.</li><li><code>/media/media0/deluge/downloads:/downloads</code>: For downloaded files.</li></ul></li><li><code>ports</code>: Maps host ports to container ports:<ul><li><code>8112:8112</code>: Web UI port.</li><li><code>6881:6881</code> and <code>6881:6881/udp</code>: Torrent ports.</li></ul></li><li><code>restart: unless-stopped</code>: Automatically restarts the container unless stopped manually.</li></ul></li></ul><h2 id="Setting-Up-Deluge"><a href="#Setting-Up-Deluge" class="headerlink" title="Setting Up Deluge"></a>Setting Up Deluge</h2><ol><li><p><strong>Create the Directory Structure</strong>: Make sure the directories in the <code>volumes</code> section exist:</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /media/media0/deluge/config</span><br><span class="line"><span class="built_in">mkdir</span> -p /media/media0/deluge/downloads</span><br></pre></td></tr></table></figure></li><li><p><strong>Run Docker Compose</strong>: Navigate to the directory with your <code>docker-compose.yml</code> file and run:</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p> The <code>-d</code> flag runs the containers in detached mode.</p></li><li><p><strong>Access the Deluge Web UI</strong>: Open your web browser and go to <code>http://&lt;your-server-ip&gt;:8112</code>. You should see the Deluge web interface.</p></li><li><p><strong>Default Password</strong>: The default password is <code>deluge</code>. Change it in the settings for security.</p></li></ol><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Setting up Deluge with Docker Compose is easy and efficient. This setup lets you manage your torrents effortlessly, providing a smooth experience. Docker simplifies the deployment process and keeps your system organized.</p><p>Feel free to customize the Docker Compose file to meet your specific needs. Happy torrenting!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Docker Compose </tag>
            
            <tag> Deluge </tag>
            
            <tag> BitTorrent </tag>
            
            <tag> Torrent Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Serial Thrillers: Bash Script for USB Identification</title>
      <link href="/2024/07/17/Serial-Thrillers-Bash-Script-for-USB-Identification/"/>
      <url>/2024/07/17/Serial-Thrillers-Bash-Script-for-USB-Identification/</url>
      
        <content type="html"><![CDATA[<p>If you need to identify USB devices connected to your Linux system, it can be a tedious process involving multiple commands and parsing all the lengthy outputs. </p><p>Automation can simplify this task significantly.</p><p>In this post, we’ll walk through a Bash script designed to list all USB devices connected to your system along with their serial numbers.</p><h4 id="The-Script"><a href="#The-Script" class="headerlink" title="The Script"></a>The Script</h4><p>Here’s the script in question:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sysdevpath <span class="keyword">in</span> $(find /sys/bus/usb/devices/usb*/ -name dev); <span class="keyword">do</span></span><br><span class="line">    (</span><br><span class="line">        syspath=<span class="string">&quot;<span class="variable">$&#123;sysdevpath%/dev&#125;</span>&quot;</span></span><br><span class="line">        devname=<span class="string">&quot;<span class="subst">$(udevadm info -q name -p $syspath)</span>&quot;</span></span><br><span class="line">        [[ <span class="string">&quot;<span class="variable">$devname</span>&quot;</span> == <span class="string">&quot;bus/&quot;</span>* ]]</span><br><span class="line">        <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(udevadm info -q property --export -p $syspath)</span>&quot;</span></span><br><span class="line">        [[ -z <span class="string">&quot;<span class="variable">$ID_SERIAL</span>&quot;</span> ]]</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;/dev/<span class="variable">$devname</span> - <span class="variable">$ID_SERIAL</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="Understanding-the-Script"><a href="#Understanding-the-Script" class="headerlink" title="Understanding the Script"></a>Understanding the Script</h4><p>Let’s break down what this script does step by step:</p><ol><li><p><strong>Finding USB Devices</strong>: The script starts by finding all device paths under <code>/sys/bus/usb/devices/usb*/</code> that end with <code>dev</code>. This path contains directories and files representing USB devices and their attributes.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sysdevpath <span class="keyword">in</span> $(find /sys/bus/usb/devices/usb*/ -name dev); <span class="keyword">do</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Extracting the Syspath</strong>: For each device path found, it extracts the parent directory path (<code>syspath</code>) by removing the trailing <code>/dev</code> part.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syspath=<span class="string">&quot;<span class="variable">$&#123;sysdevpath%/dev&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Getting the Device Name</strong>: The script uses <code>udevadm info</code> to query the device name corresponding to the syspath. This command provides details about the device.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devname=<span class="string">&quot;<span class="subst">$(udevadm info -q name -p $syspath)</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Filtering Out Non-USB Devices</strong>: The script checks if the device name starts with “bus&#x2F;“ and skips such devices since they’re not actual USB devices.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="string">&quot;<span class="variable">$devname</span>&quot;</span> == <span class="string">&quot;bus/&quot;</span>* ]]</span><br></pre></td></tr></table></figure></li><li><p><strong>Exporting Device Properties</strong>: It then uses <code>udevadm info</code> again to export all properties of the device into the current shell environment. This makes properties like <code>ID_SERIAL</code> available as shell variables.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(udevadm info -q property --export -p $syspath)</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Checking Serial Number</strong>: The script verifies if <code>ID_SERIAL</code> is set. If it’s not, it continues to the next iteration. This ensures only devices with a serial number are considered.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z <span class="string">&quot;<span class="variable">$ID_SERIAL</span>&quot;</span> ]]</span><br></pre></td></tr></table></figure></li><li><p><strong>Outputting the Device Information</strong>: Finally, the script prints the device’s path (<code>/dev/$devname</code>) along with its serial number (<code>$ID_SERIAL</code>).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/dev/<span class="variable">$devname</span> - <span class="variable">$ID_SERIAL</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="Running-the-Script"><a href="#Running-the-Script" class="headerlink" title="Running the Script"></a>Running the Script</h4><p>To use this script, save it to a file, for example <code>list_usb_devices.sh</code>, and give it execute permissions:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x list_usb_devices.sh</span><br></pre></td></tr></table></figure><p>Run the script with:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./list_usb_devices.sh</span><br></pre></td></tr></table></figure><p>This will output a list of all connected USB devices and their serial numbers, like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1 - 1234567890</span><br><span class="line">/dev/sdb1 - 0987654321</span><br></pre></td></tr></table></figure><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>This Bash script offers an approach to identify USB devices and their serial numbers on a Linux system. It’s based on <code>udevadm</code> to gather information about each device. By automating this process, you can save time and reduce the complexity involved in managing USB devices.</p><p>Feel free to adapt and expand this script based on your specific requirements. Happy scripting!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Bash Scripting </tag>
            
            <tag> Linux Automation </tag>
            
            <tag> USB Device Management </tag>
            
            <tag> udevadm </tag>
            
            <tag> System Administration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blogging for Dummies: Hexo GitHub Pages Edition</title>
      <link href="/2024/07/15/Blogging-for-Dummies-Hexo-GitHub-Pages-Edition/"/>
      <url>/2024/07/15/Blogging-for-Dummies-Hexo-GitHub-Pages-Edition/</url>
      
        <content type="html"><![CDATA[<h1 id="Step-by-Step-Guide-to-Create-a-Hexo-GitHub-Pages-Blog"><a href="#Step-by-Step-Guide-to-Create-a-Hexo-GitHub-Pages-Blog" class="headerlink" title="Step-by-Step Guide to Create a Hexo GitHub Pages Blog"></a>Step-by-Step Guide to Create a Hexo GitHub Pages Blog</h1><p>Hexo is a fast, simple, and powerful blogging framework. This guide will walk you through the process of creating a Hexo blog and deploying it to GitHub Pages.</p><h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>Before you begin, make sure you have the following installed:</p><ol><li><a href="https://nodejs.org/">Node.js</a></li><li><a href="https://git-scm.com/">Git</a></li></ol><h2 id="Step-1-Install-Hexo"><a href="#Step-1-Install-Hexo" class="headerlink" title="Step 1: Install Hexo"></a>Step 1: Install Hexo</h2><p>Open your terminal and run the following command to install Hexo globally:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="Step-2-Set-Up-Your-Blog"><a href="#Step-2-Set-Up-Your-Blog" class="headerlink" title="Step 2: Set Up Your Blog"></a>Step 2: Set Up Your Blog</h2><p>Create a new directory for your blog and navigate into it:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-blog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br></pre></td></tr></table></figure><p>Initialize a new Hexo project:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="Step-3-Configure-Your-Blog"><a href="#Step-3-Configure-Your-Blog" class="headerlink" title="Step 3: Configure Your Blog"></a>Step 3: Configure Your Blog</h2><p>Open the <code>_config.yml</code> file in the root of your Hexo project with a text editor and configure your blog settings. Pay special attention to the <code>url</code>, <code>title</code>, and <code>author</code> settings.</p><h2 id="Step-4-Create-a-New-Post"><a href="#Step-4-Create-a-New-Post" class="headerlink" title="Step 4: Create a New Post"></a>Step 4: Create a New Post</h2><p>You can create a new blog post using the following command:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;My First Post&quot;</span></span><br></pre></td></tr></table></figure><p>This will create a new Markdown file in the <code>source/_posts</code> directory. Open this file and edit your post.</p><h2 id="Step-5-Generate-Static-Files"><a href="#Step-5-Generate-Static-Files" class="headerlink" title="Step 5: Generate Static Files"></a>Step 5: Generate Static Files</h2><p>Generate the static files for your blog:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>You can preview your blog locally by running:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>Open <a href="http://localhost:4000/">http://localhost:4000</a> in your browser to see your blog.</p><h2 id="Step-6-Deploy-to-GitHub-Pages"><a href="#Step-6-Deploy-to-GitHub-Pages" class="headerlink" title="Step 6: Deploy to GitHub Pages"></a>Step 6: Deploy to GitHub Pages</h2><h3 id="Create-a-GitHub-Repository"><a href="#Create-a-GitHub-Repository" class="headerlink" title="Create a GitHub Repository"></a>Create a GitHub Repository</h3><ol><li>Go to <a href="https://github.com/">GitHub</a> and create a new repository named <code>username.github.io</code>, where <code>username</code> is your GitHub username.</li></ol><h3 id="Install-Hexo-Deployer"><a href="#Install-Hexo-Deployer" class="headerlink" title="Install Hexo Deployer"></a>Install Hexo Deployer</h3><p>Install the Hexo deployer for GitHub Pages:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="Configure-Deployment-Settings"><a href="#Configure-Deployment-Settings" class="headerlink" title="Configure Deployment Settings"></a>Configure Deployment Settings</h3><p>Open the <code>_config.yml</code> file again and add the following deployment settings at the bottom:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>Replace <code>username</code> with your GitHub username.</p><h3 id="Deploy-Your-Blog"><a href="#Deploy-Your-Blog" class="headerlink" title="Deploy Your Blog"></a>Deploy Your Blog</h3><p>Run the following command to deploy your blog to GitHub Pages:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h2 id="Step-7-Visit-Your-Blog"><a href="#Step-7-Visit-Your-Blog" class="headerlink" title="Step 7: Visit Your Blog"></a>Step 7: Visit Your Blog</h2><p>Open your browser and navigate to <code>https://username.github.io</code> to see your live blog.</p><h2 id="Optional-Customize-Your-Theme"><a href="#Optional-Customize-Your-Theme" class="headerlink" title="Optional: Customize Your Theme"></a>Optional: Customize Your Theme</h2><p>Hexo supports a variety of themes. You can find themes in the <a href="https://hexo.io/themes/">Hexo Themes</a> gallery. To install a theme:</p><ol><li>Download the theme and unzip it into the <code>themes</code> directory of your Hexo project.</li><li>Update the <code>_config.yml</code> file to set the <code>theme</code> value to the name of your new theme.</li><li>Customize the theme settings as needed.</li></ol><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>You have successfully created and deployed a Hexo blog on GitHub Pages. Happy blogging!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub Pages </tag>
            
            <tag> blogging </tag>
            
            <tag> Node.js </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
